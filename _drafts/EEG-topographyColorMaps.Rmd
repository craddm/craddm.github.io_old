---
title: 'Creating topographical scalp maps: part 2 - colour maps'
comments: yes
layout: post
output:
  html_document: default
  pdf_document: default
  word_document: default
categories:
- EEG
- ERPs
- R
- ggplot2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

In my previous post on plotting topographies in R, I was aiming for maximum comparability with EEGLAB defaults. That meant I used the 'jet' colour map, which is what I'm most used to using. While *jet* produces nice, punchy looking images, there are a heap of problems associated with it. I'm not going to rehash them in detail here, as there are numerous other posts all over the internet that do them all much better justice than I will, and I try to choose which wheels to reinvent wisely. If you want to read in more detail, check out ["The rainbow is dead, long live the rainbow"](https://mycarta.wordpress.com/2012/05/12/the-rainbow-is-dead-long-live-the-rainbow-part-1/) by Matteo Niccoli and a helpful PDF summarising the whole debate over on [Mathworks](https://www.mathworks.com/tagteam/81137_92238v00_RainbowColorMap_57312.pdf).

Here's two major points:

* Jet is not perceptually uniform. The difference between colours is not linear with increasing distance between points. It can change very quickly with small changes in value, and yet can also be very similar for relatively large differences.
* Jet is not robust to colour blindness. It's inconsistent across its range and it can be hard figuring out which colours are high and which low.

If you're still not convinced, even Matlab changed their default from 'jet' to 'parula' in version 2014b, which was news to me as I am stuck with 2012b.

Luckily, there are a whole bunch of other options for colour maps out there. Let's investigate a few.


```{r loadPackages,message = FALSE, echo = FALSE, warning = FALSE, fig.width= 4, fig.height= 4}
library(tidyverse)
library(scales)
library(gridExtra)
library(png)

topotest <- read_csv("https://raw.githubusercontent.com/craddm/ExploringERPs/master/topographyTest.csv") %>%
  gather(electrode, amplitude, -Times)
topotest$amplitude <- as.double(topotest$amplitude)
electrodeLocs <- read_delim("https://raw.githubusercontent.com/craddm/ExploringERPs/master/biosemi70elecs.loc",
                            "\t",
                            escape_double = FALSE,
                            col_names = c("chanNo","theta","radius","electrode"),
                            trim_ws = TRUE)
electrodeLocs$radianTheta <- pi/180*electrodeLocs$theta

electrodeLocs <- electrodeLocs %>%
  mutate(x = .$radius*sin(.$radianTheta),
         y = .$radius*cos(.$radianTheta))

theme_topo <- function(base_size = 12)
  {
  theme_bw(base_size = base_size) %+replace%
      theme(
            rect             = element_blank(),
            line             = element_blank(),
            axis.text = element_blank(),
            axis.title = element_blank()
           )
}

circleFun <- function(center = c(0,0),diameter = 1, npoints = 100) {
  r = diameter / 2
  tt <- seq(0,2*pi,length.out = npoints)
  xx <- center[1] + r * cos(tt)
  yy <- center[2] + r * sin(tt)
  return(data.frame(x = xx, y = yy))
}

headShape <- circleFun(c(0, 0), round(max(electrodeLocs$x)), npoints = 100) # 0

nose <- data.frame(x = c(-0.075,0,.075),y=c(.495,.575,.495))

maskRing <- circleFun(diameter = 1.42) 

#Define Matlab-style Jet colourmap
jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))

allData <- topotest %>% left_join(electrodeLocs, by = "electrode")

#select a Timepoint
singleTimepoint <- filter(allData,Times == 170.90)

rmax <- .75   #specify a maximum boundary for the grid
gridRes <- 67 #specify the interpolation grid resolution

## Create a function to perform Matlab's v4 interpolation.
## Takes as input a data-frame with columns x, y, and z (x co-ordinates, y co-ordinates, and amplitude)
## and variables xo and yo, the co-ordinates which will be use to create a grid for interpolation

v4Interp <- function(df, xo, yo, rmax = .75, gridRes = 67) {
  xo <- matrix(rep(xo,length(yo)),nrow = length(xo),ncol = length(yo))
  yo <- t(matrix(rep(yo,length(xo)),nrow = length(yo),ncol = length(xo)))
  xy <- df$x + df$y*sqrt(as.complex(-1))
  d <- matrix(rep(xy,length(xy)),nrow = length(xy), ncol = length(xy))
  d <- abs(d - t(d))
  diag(d) <- 1
  g <- (d^2) * (log(d)-1)   # Green's function.
  diag(g) <- 0
  weights <- qr.solve(g,df$z)
  xy <- t(xy)
  outmat <- matrix(nrow = gridRes,ncol = gridRes)
  for (i in 1:gridRes){
    for (j in 1:gridRes) {
      test4 <- abs((xo[i,j] + sqrt(as.complex(-1))*yo[i,j]) - xy)
      g <- (test4^2) * (log(test4)-1)
      outmat[i,j] <- g %*% weights
      }
  }
  outDf <- data.frame(x = xo[,1],outmat)
  names(outDf)[1:length(yo[1,])+1] <- yo[1,]
  #return(list(x = xo[,1],y = yo[1,],z = outmat))
  return(outDf)
}

## Create data frame to be used for interpolation - the function needs columns labelled x, y, and z

testDat<- data.frame(x = singleTimepoint$x,
                     y = singleTimepoint$y,
                     z = singleTimepoint$amplitude)

#Create the interpolation grid
xo <- seq(min(-rmax, testDat$x), max(rmax, testDat$x), length = gridRes)
yo <- seq(max(rmax, testDat$y), min(-rmax, testDat$y), length = gridRes)

interpV4 <- v4Interp(testDat, xo, yo)

interpV4 <- gather(interpV4,
                   key = y,
                   value = amplitude,
                   -x,
                   convert = TRUE) 

interpV4$incircle <- (interpV4$x)^2 + (interpV4$y)^2 < 0.7 ^ 2 # mark

v4plot <- ggplot(interpV4[interpV4$incircle,],aes(x = x, y = y, fill = amplitude))+
  geom_raster()+
  stat_contour(aes(z = amplitude),
               binwidth = 0.4,
               colour = "black")+
  theme_topo()+
   geom_path(data = maskRing,
            aes(x, y, z = NULL, fill =NULL),
            colour = "white",
            size = 6)+
  scale_fill_gradientn(colours = jet.colors(10),
                       limits = c(-2,2),
                       guide = "colourbar",
                       oob = squish)+
  geom_point(data = singleTimepoint,
             aes(x,y),
             size = 1)+
  geom_path(data = headShape,
            aes(x,y,z = NULL,fill = NULL),
            size = 1.5)+
  geom_path(data = nose,
            aes(x, y, z = NULL, fill = NULL),
            size = 1.5)+
  coord_equal()

v4plot
```
##Sequential colour maps

```{r plotViridis, warning = FALSE, message = FALSE}
library(viridis)
viridisPlot <- v4plot + scale_fill_gradientn(colours = viridis(10),
                              limits = c(-2,2),
                              guide = "colourbar",
                              oob = squish) +
  ggtitle('Viridis')
magmaPlot <- v4plot + scale_fill_gradientn(colours = viridis(10, option = "A"),
                              limits = c(-2,2),
                              guide = "colourbar",
                              oob = squish)+
  ggtitle('Magma')

infernoPlot <- v4plot + scale_fill_gradientn(colours = viridis(10, option = "B"),
                              limits = c(-2,2),
                              guide = "colourbar",
                              oob = squish)+
  ggtitle('Inferno')
plasmaPlot <- v4plot + scale_fill_gradientn(colours = viridis(10, option = "C"),
                              limits = c(-2,2),
                              guide = "colourbar",
                              oob = squish)+
  ggtitle('Plasma')

grid.arrange(viridisPlot, magmaPlot, infernoPlot, plasmaPlot, ncol = 2, nrow = 2)
```

##Diverging colour maps
```{r diverge,warning = FALSE,message = FALSE}
 RdBuPlot <- v4plot + scale_fill_distiller(type = "div",palette = "RdBu",limits = c(-2,2),
                              guide = "colourbar",
                              oob = squish) +
  ggtitle('Red-Blue')

 # RdBuPlot <- v4plot + scale_fill_gradient2(low = "blue",mid = "white",high = "red",midpoint = 0,limits = c(-2,2),
 #                              guide = "colourbar",
 #                              oob = squish) +
 #  ggtitle('Red-Blue')

PuOrPlot <- v4plot + scale_fill_distiller(type = "div",palette = "PuOr",limits = c(-2,2),
                              guide = "colourbar",
                              oob = squish) +
  ggtitle('Purple-Orange')

RdYlGnPlot <- v4plot + scale_fill_distiller(type = "div",palette = "RdYlGn",limits = c(-2,2),
                              guide = "colourbar",
                              oob = squish) +
  ggtitle('Red-Yellow-Green')

PiYGPlot <- v4plot + scale_fill_distiller(type = "div",palette = "PiYG",limits = c(-2,2),
                              guide = "colourbar",
                              oob = squish) +
  ggtitle('Pink-Yellow-Green')

grid.arrange(RdBuPlot, PuOrPlot, RdYlGnPlot, PiYGPlot, ncol = 2, nrow = 2)
```